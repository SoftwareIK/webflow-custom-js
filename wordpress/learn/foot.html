<script>
  function generateWebinarSlots({ count, country, targetTimezone, webinarType }) {
    const getSlotConfigs = (region) => {
      switch (region) {
        case "IND":
          return {
            skipDay: 0, // Skip Sunday
            timeSlots: {
              0: null, // Skip Sunday
              1: "18:00:00", // Monday
              2: "18:00:00", // Tuesday
              3: "18:00:00", // Wednesday
              4: "18:00:00", // Thursday
              5: "18:00:00", // Friday
              6: "11:00:00", // Saturday
            },
            timeZone: "Asia/Kolkata",
            utcOffset: 5.5, // Offset in hours
          };
        default:
          return {
            skipDay: 6, // Skip Saturday
            timeSlots: {
              0: "20:30:00", // Sunday
              1: "19:30:00", // Monday
              2: "20:30:00", // Tuesday
              3: "19:30:00", // Wednesday
              4: "20:30:00", // Thursday
              5: "19:30:00", // Friday
              6: null, // Skip Saturday
            },
            timeZone: "America/New_York",
            utcOffset: -5, // Offset in hours
          };
      }
    };
    const formatDateWithTimezone = (date, offsetHours) => {
      // Get the year, month, day, hours, minutes, and seconds from the date
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      const seconds = String(date.getSeconds()).padStart(2, "0");

      // Calculate the absolute offset in hours and minutes
      const totalMinutesOffset = offsetHours * 60; // Convert fractional offset to total minutes
      const offsetHoursPart = Math.floor(Math.abs(totalMinutesOffset) / 60); // Integer hours
      const offsetMinutesPart = Math.abs(totalMinutesOffset) % 60; // Remainder as minutes

      // Construct the offset string in Â±HH:mm format
      const formattedOffset = `${offsetHours >= 0 ? "+" : "-"}${String(
        offsetHoursPart
      ).padStart(2, "0")}:${String(offsetMinutesPart).padStart(2, "0")}`;

      // Combine into the final ISO format
      return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${formattedOffset}`;
    };
    const convertToUTC = (dateString) => {
      // Parse the date using the timezone in the input string
      const localDate = new Date(dateString);

      // Convert to UTC components
      const utcYear = localDate.getUTCFullYear();
      const utcMonth = String(localDate.getUTCMonth() + 1).padStart(2, "0"); // Months are 0-indexed
      const utcDate = String(localDate.getUTCDate()).padStart(2, "0");
      const utcHours = String(localDate.getUTCHours()).padStart(2, "0");
      const utcMinutes = String(localDate.getUTCMinutes()).padStart(2, "0");
      const utcSeconds = String(localDate.getUTCSeconds()).padStart(2, "0");

      // Construct the UTC string in the desired format
      return `${utcYear}-${utcMonth}-${utcDate}T${utcHours}:${utcMinutes}:${utcSeconds}+00:00`;
    };
    const toTargetTimezone = (dateString, targetTimezone) => {
      // Parse the input date string
      const date = new Date(dateString);

      // Use Intl.DateTimeFormat to format the date in the target timezone
      const formatter = new Intl.DateTimeFormat("en-US", {
        timeZone: targetTimezone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hourCycle: "h23", // 24-hour format
      });

      // Format the date to the target timezone
      const parts = formatter.formatToParts(date);

      // Extract parts and construct ISO string
      const year = parts.find((p) => p.type === "year").value;
      const month = parts.find((p) => p.type === "month").value;
      const day = parts.find((p) => p.type === "day").value;
      const hour = parts.find((p) => p.type === "hour").value;
      const minute = parts.find((p) => p.type === "minute").value;
      const second = parts.find((p) => p.type === "second").value;

      return `${year}-${month}-${day}T${hour.padStart(2, "0")}:${minute.padStart(
        2,
        "0"
      )}:${second.padStart(2, "0")}`;
    };
    const formatTime = (date) => {
      return date
        .toLocaleString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        })
        ?.replaceAll(" ", "");
    };
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, "0"); // Pad day with leading zero
      const month = date.toLocaleString("en-US", { month: "long" });
      const year = date.getFullYear();
      const weekday = date.toLocaleString("en-US", { weekday: "long" });

      return `${weekday}, ${month} ${day}, ${year}`;
    };
    const addOffset = (dateString, timezone) => {
      try {
        const date = new Date();
        const options = { timeZone: timezone, timeZoneName: "longOffset" };

        let offset =
          Intl.DateTimeFormat("en-US", options)
            .formatToParts(date)
            .find((part) => part.type === "timeZoneName")
            ?.value?.replace("GMT", "") || "+00:00";

        // Add padding to hours if needed
        if (offset.match(/^[+-]\d:/)) {
          offset = offset.replace(/^([+-])(\d):/, "$10$2:");
        }

        return `${dateString}${offset}`;
      } catch {
        return `${dateString}"+00:00"`;
      }
    };

    const slotConfig = getSlotConfigs(country);

    if (!slotConfig) {
      throw new Error("Invalid country.");
    }

    const {
      skipDay,
      timeSlots,
      utcOffset: slotUTCOffset,
      timeZone: slotTimezone,
    } = slotConfig;

    const result = [];
    const now = new Date(
      new Date().toLocaleString("en-US", { timeZone: slotTimezone })
    );

    for (let i = 0; i < count; i++) {
      const startSlotTime = new Date(now);
      startSlotTime.setDate(startSlotTime.getDate() + i);

      const day = startSlotTime.getDay();
      if (day === skipDay) {
        continue;
      }

      const slotTime = timeSlots[day];
      if (!slotTime) {
        continue;
      }

      const [hours, minutes, seconds] = slotTime.split(":").map(Number);
      startSlotTime.setHours(hours);
      startSlotTime.setMinutes(minutes);
      startSlotTime.setSeconds(seconds);

      // Skip past slots
      if (startSlotTime < new Date(now)) {
        continue;
      }

      const endSlotTime = new Date(startSlotTime);
      endSlotTime.setHours(endSlotTime.getHours() + 1);

      const formatted_start_slot_time = formatDateWithTimezone(
        startSlotTime,
        slotUTCOffset
      );
      const formatted_end_slot_time = formatDateWithTimezone(
        endSlotTime,
        slotUTCOffset
      );

      const user_start_time_obj = new Date(
        toTargetTimezone(formatted_start_slot_time, targetTimezone)
      );
      const user_end_time_obj = new Date(
        toTargetTimezone(formatted_end_slot_time, targetTimezone)
      );

      result.push({
        start_time: addOffset(
          toTargetTimezone(formatted_start_slot_time, targetTimezone),
          targetTimezone
        ),
        end_time: addOffset(
          toTargetTimezone(formatted_end_slot_time, targetTimezone),
          targetTimezone
        ),
        utc_start_time: convertToUTC(formatted_start_slot_time),
        utc_end_time: convertToUTC(formatted_end_slot_time),
        day: String(user_start_time_obj.getDate()).padStart(2, "0"),
        month: String(user_start_time_obj.getMonth() + 1).padStart(2, "0"),
        year: String(user_start_time_obj.getFullYear()),
        hour: String(user_start_time_obj.getHours() % 12 || 12).padStart(2, "0"),
        minute: String(user_start_time_obj.getMinutes()).padStart(2, "0"),
        second: String(user_start_time_obj.getSeconds()).padStart(2, "0"),
        am_or_pm: user_start_time_obj.getHours() >= 12 ? "PM" : "AM",
        weekday: user_start_time_obj.toLocaleString("en-US", { weekday: "long" }),
        invitee_start_time: `${formatTime(user_start_time_obj)} - ${formatDate(
          user_start_time_obj
        )}`,
        invitee_end_time: `${formatTime(user_end_time_obj)} - ${formatDate(
          user_end_time_obj
        )}`,
        webinar_lead_type: webinarType,
      });
    }
    return result;
  }
</script>
<script>

  let registration_type;
  let no_of_webinar_slots = 6;
  let slotFetchedTwice = false;
  let initnialWebinarType = webinarType;
  let initialTimezone = v_timezone;
  let staticSlots = generateWebinarSlots({ count: 13, country: "USA", targetTimezone: v_timezone, webinarType: webinarType });
  slotLoaded(staticSlots);

  function populateWebinarSlots(resobj) {
    const t_months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    if (resobj.length == 0) {
      console.error("P0: The Uplevel Webinar Slots API Returned No Data.");
      registration_type = "calendly";
    } else {
      registration_type = "byecalendly";
    }

    no_of_webinar_slots = (no_of_webinar_slots == undefined) ? 4 : no_of_webinar_slots;
    let nslots = (resobj.length > no_of_webinar_slots) ? no_of_webinar_slots : resobj.length;
    var tz = new Date().toString().match(/\((.+)\)/);
    if (tz[1].includes(" ")) {
      tz = tz[1]
        .split(" ")
        .map(([first]) => first)
        .join("");
    }

    const getWebinerSlots = document.querySelector('.webnear_regitration_fr .fr_stage_2 .web_near_slot');
    getWebinerSlots.innerHTML = "";

    for (i = 0; i < nslots; i++) {
      let hdate = resobj[i].weekday + ", " + resobj[i].day + " " + t_months[parseInt(resobj[i].month) - 1] + " " + resobj[i].year + " | " + resobj[i].hour + ":" + resobj[i].minute + " " + resobj[i].am_or_pm;

      let checkStatus = i == 0 ? "checked" : "";
      let radiohtml = document.createElement('label');
      radiohtml.innerHTML = `
              <input type="radio" 
              name="start-date"
              value="${resobj[i].start_time}" 
              data-endtime="${resobj[i].end_time}" 
              data-invitee_starttime="${resobj[i].invitee_start_time}" 
              data-invitee_endtime="${resobj[i].invitee_end_time}" 
              data-name="${resobj[i].start_time}" 
              data-webinar_lead_type="${resobj[i].webinar_lead_type}"
              ${checkStatus} 
              required="required">
              <span class="text">${hdate} </span>
          `;

      getWebinerSlots.append(radiohtml);
    }
  }

  async function fallbackSlots() {
    if (!slotFetchedTwice) {
      let initnialWebinarType = webinarType;
      let initialTimezone = v_timezone;
      webinarType = "REGULAR";
      v_timezone = "America/New_York"
      loadSlot(v_timezone)
      slotFetchedTwice = true;
    } else {
      webinarType = initnialWebinarType;
      v_timezone = initialTimezone;
      slotLoaded(staticSlots);
    }
  }

  async function slotLoaded(slots) {
    document.dispatchEvent(webNearLoadedEv);
    if (!is_webinar_1o1_eligible) {
      populateWebinarSlots(slots);
    }
    TimerHandler(resobj);
  }

  async function loadSlot(c_timezoon = "Asia/Kolkata") {
    let api_url = `https://uplevel.interviewkickstart.com/api/webinar-slot/upcoming-slots/?country=USA&program=Backend&timezone=${c_timezoon.replace("+", "%2B")}&type=${webinarType === "SWITCH_UP" ? webinarType : "REGULAR"}`;

    const option = {
      method: "GET",
      headers: {
        "Authorization": "1Cgx6oYXkOlWkNDn7_tXO",
      }
    }
    try {
      const request = await fetch(api_url, option);
      let resobj = await request.json();
      resobj = resobj.map(item => ({ ...item, webinar_lead_type: webinarType }));
      slotLoaded(resobj);
      if (!is_webinar_1o1_eligible) {
        populateWebinarSlots(resobj);
      }
    } catch (err) {
      fallbackSlots()
    }
  }

  getGeo().then((geo) => {
    loadSlot(geo.timezone);
  }).catch(() => {
    loadSlot();
  })

  async function getGeo() {
    let response = await fetch("https://get.geojs.io/v1/ip/geo.json");
    let data = await response.json();
    return data;
  }


  /*-----------------------------------------------------Time Functions Start------------------------------------------------------------------------*/
  const timerState = {
    currentDate: '',
    nextDate: '',
    currentDateSec: '',
    nextDateSec: '',
  };

  function initStates(slots, tz) {
    try {
      timerState.currentDate = new Date().toLocaleString('en-US', { timeZone: tz });
    } catch (err) {
      console.log(err);
    }

    timerState.currentDateSec = Date.parse(timerState.currentDate);
    timerState.nextDate = nextWebinar(timerState.currentDate.split(',')[0], timerState.currentDateSec, slots, tz);
    if (timerState.nextDate !== '') {
      timerState.nextDateSec = Date.parse(timerState.nextDate);
    }
  };

  function nextWebinar(currentDate, currentWebTime, slots, tz) {
    let nextWebinarDate = '';
    if (!slots) {
      return fallbackTimerDate(tz)
    }

    const formattedSlots = (slots || [])?.map((slot = {}) => ({
      date: `${slot.month}/${slot.day}/${slot.year}`, //"06/12/2024"
      time: `${slot.hour}:${slot.minute}:${slot.second} ${slot.am_or_pm}`, //"07:30:00 PM"
    }))

    for (let idx = 0; idx < formattedSlots.length; idx++) {
      if (formattedSlots[idx]) {
        const currentDateWeb = Date.parse(new Date(`${formattedSlots[idx].date}, ${formattedSlots[idx].time}`));
        if (currentDateWeb > currentWebTime) {
          nextWebinarDate = `${formattedSlots[idx].date}, ${formattedSlots[idx].time}`;
          break;
        }
      }
    }
    console.log(nextWebinarDate);
    return nextWebinarDate;
  };

  // Fall back time
  function fallbackTimerDate(tz) {
    const isIndia = tz == "IST" || tz == "Asia/Kolkata";

    const currentDate = new Date();
    const dayOfWeek = currentDate.getDay(); // 0: Sunday, 1: Monday, ..., 6: Saturday
    const dateString = currentDate.toLocaleDateString('en-US', { timeZone: 'Asia/Kolkata', month: '2-digit', day: '2-digit', year: 'numeric' });
    let timeString;

    if (isIndia) {
      if (dayOfWeek === 6) {
        // Saturday
        timeString = "11:00:00 PM";
      } else if (dayOfWeek === 0) {
        // Sunday
        return ""; // Skip on Sunday
      } else {
        timeString = "06:00:00 PM";
      }
    } else {
      if (dayOfWeek === 6) {
        // Saturday
        return ""; // Skip on Saturday
      } else if (dayOfWeek % 2 === 1) {
        // Odd days (Monday, Wednesday, Friday, Sunday)
        timeString = "07:30:00 PM";
      } else {
        // Even days (Tuesday, Thursday)
        timeString = "08:30:00 PM";
      }
    }

    return `${dateString}, ${timeString}`
  }

  function unitCount(unit) {
    const toTens = () => String(Number.parseInt(unit / 10));
    const toOnes = () => String(unit % 10);
    return toTens() + toOnes();
  };

  function TimerHandler(slots) {

    let tz = "America/New_York"
    if (typeof (v_timezone) != "undefined") {
      tz = v_timezone;
    }

    // initialize states
    initStates(slots, tz);

    // start timer
    const webinarTimer = setInterval(() => {
      if (timerState.nextDate === '') {
        clearInterval(webinarTimer);
      }
      timerState.currentDate = new Date().toLocaleString('en-US', { timeZone: tz });
      timerState.currentDateSec = Date.parse(timerState.currentDate);

      const distanceCount = timerState.nextDateSec - timerState.currentDateSec;

      const day = Math.floor(distanceCount / (1000 * 60 * 60 * 24));
      const hrs = Math.floor((distanceCount % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const min = Math.floor((distanceCount % (1000 * 60 * 60)) / (1000 * 60));
      const sec = Math.floor((distanceCount % (1000 * 60)) / 1000);

      // separating into tens and ones

      const dayCount = unitCount(day);
      const hrCount = unitCount(hrs);
      const minCount = unitCount(min);
      const secCount = unitCount(sec);

      // update UI
      updateTimerUI(dayCount, hrCount, minCount, secCount);

      if (distanceCount <= 0) {
        // move timer to next date if reached 0
        initStates(slots, tz);

        if (timerState.nextDate === '') {
          clearInterval(webinarTimer);
          // hide the fild if nothing
          document.querySelectorAll('.webinar__timer').forEach((timer) => {
            timer.classList.add('is-hidden');
          });
        }
      }
    }, 1000);
  };

  // set the next webnear value
  function updateTimerUI(day, hrs, min, sec) {
    document.querySelectorAll('.webinar__timer--days h2').forEach((timer) => {
      timer.textContent = day;
    });
    document.querySelectorAll('.webinar__timer--hours h2').forEach((timer) => {
      timer.textContent = hrs;
    });
    document.querySelectorAll('.webinar__timer--mins h2').forEach((timer) => {
      timer.textContent = min;
    });
    document.querySelectorAll('.webinar__timer--secs h2').forEach((timer) => {
      timer.textContent = sec.slice(0,2);
    });
  };
  /*-----------------------------------------------------Time Functions End------------------------------------------------------------------------*/
</script>




<!------------------ Webnear Form Send ---------------------->
<script>
  // get all from fild
  const getThePopupFrom = document.querySelector('.webnear_regitration_fr');

  const webNearFullName = getThePopupFrom.querySelector('.web_full_name input#Full-Name');
  const webNearEmailAddress = getThePopupFrom.querySelector('.web_em_address input#Email-Address-7');
  const webNearPhoneNumber = getThePopupFrom.querySelector('.web_phone_number input#webinar_pnumber');
  const webNearAccepTance = getThePopupFrom.querySelector('.fr_acceptance input#Whatsapp-User-Consent');
  const webNearSlots = getThePopupFrom.querySelector('.web_near_slot');
  let webNearPhoneNumberWri;

  intlTelInputCheckFun(function () {
    webNearPhoneNumberWri = window.intlTelInput(webNearPhoneNumber, {
      initialCountry: "auto",
      geoIpLookup: function (callback) {
        getGeo()
          .then((resp) => { callback(resp.country_code); })
          .catch(() => callback('in'));

        // fetch('https://ipinfo.io', { headers: { 'Accept': 'application/json' } })
        //   .then((resp) => resp.json())
        //   .then((resp) => { callback(resp.country); })
        //   .catch(() => callback('in'));
      },
      utilsScript: "https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/js/utils.js"
    });
  });





  const getFnErrMsg = getThePopupFrom.querySelector('.web_full_name');
  const getEmErrMsg = getThePopupFrom.querySelector('.web_em_address');
  const getPhErrMsg = getThePopupFrom.querySelector('.web_phone_number');

  // name container
  const webNearInfo = {
    firstName: "",
    lastName: "",
    fPhoneNumber: "",
    utm_source: "Organic",
    utm_medium: "",
    utm_campaign: "",
    utm_adset: "",
    utm_content: "",
    utm_term: "",
    page_url: page_url,
    site_url: window.location.hostname,
    user_id: "",
    gclid: "",
    salesforce_uuid: "",
    msclkid: "",
    fbclid: "",
    li_fat_id: "",
    user_timezone: "",
    l_page_url: "",
    cta_page_url: "",
    webinar_type: "",
    eventname: "",
    wr__referrer: "",
    wr__device: "",
    webinar_lead_type: "",
    bye_calendly_type: "",
    is_exit_intent_popup: "",
    v_country: "",
    wr__region: "",
    wr__city: "",
    irclickid: "",

    eventStartTime: "",
    eventEndTime: "",
    inviteStartTime: "",
    inviteEndTime: "",
    booking_id: ""
  };

  //check regex
  let name_regex = new RegExp("^[a-zA-Z ]+$");
  let email_regex = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
  let phone_regex = /^(\+\d{1,2}\s?)?1?\-?\.?\s?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;


  // getlocation json
  (async function () {
    let response = await fetch("https://get.geojs.io/v1/ip/geo.json");
    let data = await response.json();
    webNearInfo.v_country = data.country;
    webNearInfo.wr__region = data.region;
    webNearInfo.wr__city = data.city;
  })();

  function getParams(t) { var t = t ? t.split("?")[1] : window.location.search.slice(1), r = {}; if (t) for (var s = (t = t.split("#")[0]).split("&"), e = 0; e < s.length; e++) { var a, n = s[e].split("="), i = n[0], o = void 0 === n[1] || n[1]; (i = i.toLowerCase()).match(/\[(\d+)?\]$/) ? (r[a = i.replace(/\[(\d+)?\]/, "")] || (r[a] = []), i.match(/\[\d+\]$/) ? (n = /\[(\d+)\]/.exec(i)[1], r[a][n] = o) : r[a].push(o)) : r[i] ? (r[i] && "string" == typeof r[i] && (r[i] = [r[i]]), r[i].push(o)) : r[i] = o } return r }

  function setHiddenFields() {
    //  let params = read_cookie("v_latest");
    let params = [];
    try {
      params = read_cookie("v_latest") || getParams()
      bake_cookie("v_latest", params);
    } catch (error) {
      console.error("Error while reading cookie", error);
    }

    webNearInfo.utm_source = decodeURIComponent(params['utm_source'] || "Organic");
    webNearInfo.utm_medium = decodeURIComponent(params['utm_medium'] || "");
    webNearInfo.utm_campaign = decodeURIComponent(params['utm_campaign'] || "");
    webNearInfo.utm_content = decodeURIComponent(params['utm_content'] || "");
    webNearInfo.utm_term = decodeURIComponent(params['utm_term'] || "");
    webNearInfo.utm_adset = decodeURIComponent(params['utm_adset'] || "");
    webNearInfo.gclid = decodeURIComponent(params['gclid'] || "");
    webNearInfo.salesforce_uuid = decodeURIComponent(params['salesforce_uuid'] || "");
    webNearInfo.msclkid = decodeURIComponent(params['msclkid'] || "");
    webNearInfo.fbclid = decodeURIComponent(params['fbclid'] || "");
    webNearInfo.li_fat_id = decodeURIComponent(params['li_fat_id'] || "");

    webNearInfo.user_id = visitor_id;
    webNearInfo.user_timezone = v_timezone;
    //   webNearInfo.l_page_url = "learn.ik" + getCookie("ik-landingpage");
    if ((referrer || '') != "") {
      webNearInfo.l_page_url = "learn.ik/" + (referrer || '').split("/").pop();
    } else {
      webNearInfo.l_page_url = "learn.ik/" + page_url.split("/").pop();
    }
    webNearInfo.cta_page_url = "learn.ik" + cta_lp;
    webNearInfo.webinar_type = webinarType;
    webNearInfo.eventname = eventName;
    webNearInfo.wr__referrer = referrer;
    webNearInfo.wr__device = getDeviceType();

    document.querySelector('.webinar__lightbox-title h2').innerHTML = eventName;

    webNearInfo.webinar_lead_type = webinarType;
    webNearInfo.bye_calendly_type = "";
    webNearInfo.is_exit_intent_popup = "No";

    webNearInfo.irclickid = decodeURIComponent(params['irclickid'] || "");
  }
  setHiddenFields();
  // set Hidden fild end ---------------------------------------------------------


  // Push Data end point fun
  async function pushToEndPoint(endpoint, evLoad = true) {
    let getCheckWebnear = webNearSlots.querySelector('input[name="start-date"]:checked');
    webNearInfo.eventStartTime = getCheckWebnear ? getCheckWebnear.value : "";
    webNearInfo.eventEndTime = getCheckWebnear ? getCheckWebnear.getAttribute('data-endtime') : "";
    webNearInfo.inviteStartTime = getCheckWebnear ? getCheckWebnear.getAttribute('data-invitee_starttime') : "";
    webNearInfo.inviteEndTime = getCheckWebnear ? getCheckWebnear.getAttribute('data-invitee_endtime') : "";

    let formData = {
      "First Name": webNearInfo.firstName,
      "Last Name": webNearInfo.lastName,
      "Email Address": webNearEmailAddress.value,
      "ByeCalendlyType": webNearInfo.bye_calendly_type,
      "webinar-type": webNearInfo.webinar_type,
      "Webinar Lead Type": webNearInfo.webinar_lead_type,
      "utm_source": webNearInfo.utm_source,
      "utm_medium": webNearInfo.utm_medium,
      "utm_campaign": webNearInfo.utm_campaign,
      "utm_content": webNearInfo.utm_content,
      "utm_adset": webNearInfo.utm_adset,
      "utm_term": webNearInfo.utm_term,

      "City": webNearInfo.wr__city,
      "Device": webNearInfo.wr__device,
      "Referrer": webNearInfo.wr__referrer,
      "Region": webNearInfo.wr__region,

      "gclid": webNearInfo.gclid,
      "msclkid": webNearInfo.msclkid,
      "fbclid": webNearInfo.fbclid,
      "user_id": webNearInfo.user_id,
      "li_fat_id": webNearInfo.li_fat_id,

      "cta_page_url": webNearInfo.cta_page_url,
      "landing_page_url": webNearInfo.l_page_url,
      "event_name": webNearInfo.eventname,
      "user_timezone": webNearInfo.user_timezone,
      "page_url": webNearInfo.page_url,
      "site_url": webNearInfo.site_url,
      "v_country": webNearInfo.v_country,
      "salesforce_uuid": webNearInfo.salesforce_uuid,
      "phone_number_full": webNearInfo.fPhoneNumber,
      "is_exit_intent_popup": webNearInfo.is_exit_intent_popup,
      "irclickid": webNearInfo.irclickid,

      "Event Start Time": webNearInfo.eventStartTime,
      "Event End Time": webNearInfo.eventEndTime,
      "Invitee Start Time": webNearInfo.inviteStartTime,
      "Invitee End Time": webNearInfo.inviteEndTime,
    };

    try {
      formData["ipAddress"] = userIpAndBrowserInfo.ipAddress;
      formData["browserName"] = userIpAndBrowserInfo.browserName;
      formData["browserVersion"] = userIpAndBrowserInfo.browserVersion;
    } catch (err) {
      formData["browserName"] = "";
      formData["browserVersion"] = "";
      formData["ipAddress"] = "";
    }



    if (is_webinar_1o1_eligible) formData["Booking id"] = webNearInfo.booking_id;

    let options = {
      method: 'POST',
      mode: "no-cors",
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(formData),
    };

    try {
      const sendData = await fetch(endpoint, options);
      console.log("Form submitted successfully!");
      return sendData;
    } catch (err) {
      console.error("P0: The Zapier Webhook Failed.");
      alert("Something is wrong");
    }
  }


  function hideError() {
    getFnErrMsg.setAttribute('err_status', false);
    getEmErrMsg.setAttribute('err_status', false);
    getPhErrMsg.setAttribute('err_status', false);
  }

  // First Form Submittion
  function fromSend1stStep() {
    setHiddenFields();
    getThePopupFrom.setAttribute("loader_status", true);

    let fullname = webNearFullName.value.trim();
    let wEmail = webNearEmailAddress.value;
    let fullPhoneNumber = webNearPhoneNumber.value;

    //Hide errors
    webNearFullName.addEventListener('input', hideError);
    webNearEmailAddress.addEventListener('input', hideError);
    webNearPhoneNumber.addEventListener('input', hideError);
    webNearFullName.addEventListener('focus', hideError);
    webNearEmailAddress.addEventListener('focus', hideError);
    webNearPhoneNumber.addEventListener('focus', hideError);


    //Error check
    if ((fullname.length == 0) && (wEmail.length == 0) && (fullPhoneNumber.length == 0)) {
      getFnErrMsg.setAttribute('err_status', true);
      getEmErrMsg.setAttribute('err_status', true);
      getPhErrMsg.setAttribute('err_status', true);
      getThePopupFrom.setAttribute("loader_status", false);
      return;
    } else if (!name_regex.test(fullname) || fullname.length == 0) {
      getFnErrMsg.setAttribute('err_status', true);
      getThePopupFrom.setAttribute("loader_status", false);
      return;
    } else if (!email_regex.test(wEmail) || wEmail.length == 0) {
      getEmErrMsg.setAttribute('err_status', true);
      getThePopupFrom.setAttribute("loader_status", false);
      return;
    } else if (!phone_regex.test(fullPhoneNumber) || fullPhoneNumber.length == 0) {
      getPhErrMsg.setAttribute('err_status', true);
      getThePopupFrom.setAttribute("loader_status", false);
      return;
    } else if (typeof validateCaptcha !== "undefined" && !validateCaptcha()) {
      getThePopupFrom.setAttribute("loader_status", false);
      return;
    } else {

      if (fullname.substring(0, fullname.indexOf(' ')) == '') {
        webNearInfo.firstName = fullname.substring(fullname.indexOf(' ') + 1);
        webNearInfo.lastName = fullname.substring(fullname.indexOf(' ') + 1);
      } else if (fullname.substring(fullname.indexOf(' ') + 1) == '') {
        webNearInfo.firstName = fullname.substring(0, fullname.indexOf(' '));
        webNearInfo.lastName = fullname.substring(0, fullname.indexOf(' '));
      } else {
        webNearInfo.firstName = fullname.substring(0, fullname.indexOf(' '));
        webNearInfo.lastName = fullname.substring(fullname.indexOf(' ') + 1);
      }

      try {
        dataLayer.push({
          'event': 'pa_new_webinar_registration_form_submitted',
          'webinar_name': webNearInfo.eventname
        });
      } catch (err) {
        console.log("Data Layer add faild");
        console.log(err);
      }


      intlTelFunCheck(function () {
        webNearInfo.fPhoneNumber = webNearPhoneNumberWri.getNumber(intlTelInputUtils.numberFormat.E164);
        console.log(Boolean(intlTelInputUtils));
      }).then(() => {
        pushToEndPoint("https://hooks.zapier.com/hooks/catch/11068981/340hd4j/")
          .then(() => {
            getThePopupFrom.setAttribute("ac_step", 2);
            getThePopupFrom.setAttribute("loader_status", false);
          });
      })
    }
  }

  // Second Form Submition
  function fromSend2ndStep() {
    getThePopupFrom.setAttribute("loader_status", true);

    const getCheckWebnear = webNearSlots.querySelector('input[name="start-date"]:checked');

    //           let utmm = visitor_id + ":" + webNearInfo.v_country;
    let utmm = `${visitor_id}${getCookie("_ga")}:${v_country}`;
    let sf_uuid = v_timezone + ":learn.ik" + cta_lp + ":learn.ik" + getCookie("ik-landingpage");

    let utmstring = {
      assigned_to: "Interview Kickstart",
      invitee_first_name: webNearInfo.firstName,
      invitee_last_name: webNearInfo.lastName,
      invitee_email: webNearEmailAddress.value,
      answer_1: webNearInfo.fPhoneNumber,
      event_start_time: getCheckWebnear ? getCheckWebnear.value : "",
      event_end_time: getCheckWebnear ? getCheckWebnear.getAttribute('data-endtime') : "",
      utm_medium: utmm,
      salesforce_uuid: sf_uuid,
      whatsapp_consent: true
    };

    bake_cookie("from_cookie", utmstring);

    let finalurl = webinarType === "SWITCH_UP" ? "/signup-final-step-switchup" : "/signup-final-step";
    let pushUrl = is_webinar_1o1_eligible ? "https://hooks.zapier.com/hooks/catch/11068981/2dvpcc1/" : "https://hooks.zapier.com/hooks/catch/11068981/340hl1a/";



    function secondZapPushFun() {
      pushToEndPoint(pushUrl)
        .then(() => {
          secondStepSecondRequest(getCheckWebnear)
            .then(function () {
              // For A/B testing
              if (location.pathname == '/course/data-engineering-interview-masterclass/') {
                VWO.event("gqlFormCompleted", { "gqlFormCompleted": true });
              }

              console.log("redirection is called");
              console.log(finalurl);
              location.href = finalurl;
            });
        });
    }

    if (is_webinar_1o1_eligible) {
      bookSlot(webNearEmailAddress.value, getCheckWebnear.getAttribute('slot_id')).then(function (data) {
        if (data.booking_id) webNearInfo.booking_id = data.booking_id;
        secondZapPushFun();
      });
    } else {
      secondZapPushFun();
    }
  }


  // second step second request fun
  async function secondStepSecondRequest(getCheckWebnear) {
    //lead LeadCreatedTime
    const currentDateTime = new Date();
    const LeadCreatedTime = currentDateTime.toISOString().replace(/T/, ' ').replace(/\.\d+Z$/, ' UTC');

    function formatDateTime(dateTimeString) {
      const date = new Date(dateTimeString);
      const year = date.getUTCFullYear();
      const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
      const day = date.getUTCDate().toString().padStart(2, '0');
      const hours = date.getUTCHours().toString().padStart(2, '0');
      const minutes = date.getUTCMinutes().toString().padStart(2, '0');
      const seconds = date.getUTCSeconds().toString().padStart(2, '0');
      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
    }

    const formattedStartDateTime = formatDateTime(getCheckWebnear.value);
    const formattedEndDateTime = formatDateTime(getCheckWebnear.getAttribute('data-endtime'));

    let data = [{
      "Lead_Created_Time": LeadCreatedTime,
      "Lead_Name": webNearInfo.firstName + ' ' + webNearInfo.lastName,
      "Lead_First_Name": webNearInfo.firstName,
      "Lead_Last__Name": webNearInfo.lastName,
      "Lead_Email": webNearEmailAddress.value,
      "Lead_Time_Zone": webNearInfo.user_timezone,
      "Event_Type_Name": eventName,
      "Event_Start_Date_Time": formattedStartDateTime,
      "Event_End_Date_Time": formattedEndDateTime,
      "Cancellation_reason": "",
      "Mobile": webNearInfo.fPhoneNumber,
      "UTM_Campaign": webNearInfo.utm_campaign,
      "UTM_Source": webNearInfo.utm_source,
      "UTM_Medium": webNearInfo.utm_medium,
      "UTM_Term": webNearInfo.utm_term,
      "UTM_Content": webNearInfo.utm_content,
      "Tracking_ID": "",
      "User_ID": webNearInfo.user_id,
      "Page_URL": encodeURIComponent(webNearInfo.page_url),
      "Country": webNearInfo.v_country,
      "Client_Timezone": webNearInfo.user_timezone,
      "CTA_Page": encodeURIComponent(webNearInfo.cta_page_url),
      "Landing_Page": encodeURIComponent(webNearInfo.l_page_url),
      "Webinar_reg_type": "",
      "Webinar_Type": webNearInfo.webinar_type,
      "Switchup_Lead": webNearInfo.webinar_lead_type,
      "UUID": webNearInfo.salesforce_uuid,
      "Click_History": "",
      "City": webNearInfo.wr__city,
      "Device": webNearInfo.wr__device,
      "User_Agent": encodeURIComponent(navigator?.userAgent || ""),
      "Refferer": encodeURIComponent(webNearInfo.wr__referrer),
      "Region": webNearInfo.wr__region
    }];

    let options = {
      method: 'POST',
      headers: {
        'x-api-key': 'fm0X61U99b80d5SlGjrxFaWjgxIBylhX3LkfYGPN',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        dataset_id: "Marketing_data_new_logic",
        table_id: "Leads_Click_history",
        data: data,
      }),
    };

    try {
      const response = await fetch('https://nlhtyrnugl.execute-api.us-west-1.amazonaws.com/prod', options);
      console.log("Success Response");
      return response;
    } catch (err) {
      console.log(err);
    };
  }


  // get wn from btns
  const get1stepBtn = getThePopupFrom.querySelector(".step_1_btn");
  const get2stepfinishBtn = getThePopupFrom.querySelector(".step_2_btn");
  const getBackBtn = getThePopupFrom.querySelector(".fr_btn_back");

  getBackBtn.addEventListener('click', function () {
    getThePopupFrom.setAttribute("ac_step", 1);
  });

  get1stepBtn.addEventListener('click', fromSend1stStep);
  get2stepfinishBtn.addEventListener('click', fromSend2ndStep);


  try {
    if (is_webinar_1o1_eligible) {
      function render1o1Slots(resobj) {
        const getWebiner101Slots = document.querySelector('.webnear_regitration_fr .webiner_101_slots');
        const get101DateFild = getWebiner101Slots.querySelector('.select_date .date_list');
        const get101TimeFild = getWebiner101Slots.querySelector('.time_slot .time_list');
        const get101TimeZoneFild = document.querySelector('.webnear_regitration_fr .web_near_slot .time_zone');
        const month = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        get101DateFild.innerHTML = "";
        let defultSelect = true;

        get101TimeZoneFild.innerHTML = `Time Zone: ${v_timezone}`;
        console.log("test", v_timezone);

        const localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        function convertUTCToLocal(availableSlots) {
          const localSlots = {};

          for (const date in availableSlots) {
            for (const time in availableSlots[date]) {
              const utcDateTime = new Date(`${date}T${time}:00Z`);
              const localDateTime = new Date(
                utcDateTime.toLocaleString("en-US", { timeZone: localTimeZone })
              );

              const localDate = `${localDateTime.getFullYear()}-${(
                "0" + (localDateTime.getMonth() + 1)
              ).slice(-2)}-${("0" + localDateTime.getDate()).slice(-2)}`;
              const localTime = localDateTime
                .toTimeString()
                .split(" ")[0]
                .slice(0, 5);

              if (!localSlots[localDate]) {
                localSlots[localDate] = {};
              }

              localSlots[localDate][localTime] = availableSlots[date][time];
            }
          }

          return localSlots;
        }

        resobj = convertUTCToLocal(resobj);

        Object.keys(resobj).sort((a, b) => {
          const timeA = new Date(`${a}T00:00`).getTime();
          const timeB = new Date(`${b}T00:00`).getTime();
          return timeA - timeB;
        }).forEach(function (date, index) {
          let datObj = new Date(date + "T00:00:00");
          let get101Month, get101Date;
          try {
            get101Month = month[datObj.getMonth()];
            get101Date = datObj.getDate();
          } catch (err) {
            get101Month = "";
            get101Date = "";
          }

          const dataElement = document.createElement("label");
          dataElement.innerHTML = `
                      <span>${get101Month} ${get101Date}</span>
                      <input type="radio" name="date_fild" ${defultSelect ? "checked" : ""} date="${date}" >
                  `;
          get101DateFild.appendChild(dataElement);

          if (defultSelect) {
            render101Time(date);
            defultSelect = false;
          }
          dataElement.addEventListener("click", function () {
            render101Time(date);
          })
        })

        function render101Time(selectedDate) {
          get101TimeFild.innerHTML = "";
          let times = resobj[selectedDate];
          let defultTimeSelect = true;

          Object.keys(times).sort((a, b) => {
            const timeA = new Date(`1970-01-01T${a}:00`).getTime();
            const timeB = new Date(`1970-01-01T${b}:00`).getTime();
            return timeA - timeB;
          }).forEach(function (time, index) {
            const timeElement = document.createElement("label");

            const startDate = new Date(`${selectedDate}T${time}:00`);
            const endDate = new Date(startDate.getTime() + 60 * 60 * 1000);

            const inviteeStartTime =
              startDate.toLocaleTimeString("en-US", {
                hour: "numeric",
                minute: "2-digit",
                hour12: true,
                timeZone: localTimeZone, // Set the time zone to IST
              }) +
              " - " +
              startDate.toLocaleDateString("en-US", {
                weekday: "long",
                month: "long",
                day: "numeric",
                year: "numeric",
                timeZone: localTimeZone, // Set the time zone to IST
              });

            const inviteeEndTime =
              endDate.toLocaleTimeString("en-US", {
                hour: "numeric",
                minute: "2-digit",
                hour12: true,
                timeZone: localTimeZone, // Set the time zone to IST
              }) +
              " - " +
              endDate.toLocaleDateString("en-US", {
                weekday: "long",
                month: "long",
                day: "numeric",
                year: "numeric",
                timeZone: localTimeZone, // Set the time zone to IST
              });

            function formatDateWithTimezoneOffset(date) {
              const timezoneOffset = -date.getTimezoneOffset(); // offset in minutes
              const diffHours = Math.floor(timezoneOffset / 60);
              const diffMinutes = timezoneOffset % 60;
              const sign = diffHours >= 0 ? "+" : "-";
              const pad = (num) => String(Math.abs(num)).padStart(2, "0");
              return (
                date.getFullYear() +
                "-" +
                pad(date.getMonth() + 1) +
                "-" +
                pad(date.getDate()) +
                "T" +
                pad(date.getHours()) +
                ":" +
                pad(date.getMinutes()) +
                ":" +
                pad(date.getSeconds()) +
                sign +
                pad(diffHours) +
                ":" +
                pad(diffMinutes)
              );
            }

            timeElement.innerHTML = `
                              <span>${time}</span>
                              <input type="radio" name="start-date" 
                              time="${time}" 
                              slot_id="${times[time]}"
                              value="${formatDateWithTimezoneOffset(startDate)}"
                              data-endtime="${formatDateWithTimezoneOffset(endDate)}"
                              data-invitee_starttime="${inviteeStartTime}"
                              data-invitee_endtime="${inviteeEndTime}"
                              ${defultTimeSelect ? "checked" : ""}>
                      `
            get101TimeFild.appendChild(timeElement);
            if (defultTimeSelect) defultTimeSelect = false;
          })
        }
      }

      (async function () {
        const option = {
          method: "GET",
          headers: {
            "Authorization": "1Cgx6oYXkOlWkNDn7_tXO",
          }
        }

        const request = await fetch('https://uplevel.interviewkickstart.com/api/v1/webinar_connect/available-slots/', option);
        let resobj = await request.json();
        render1o1Slots(resobj);
      })();
    }
  } catch (err) {
    console.log("1o1 error happen");
  }

  function initObservers() {
    let scrollPosition = 0;
    try {
      if (window.MutationObserver) {
        // Function to handle mutation
        function handleMutation(mutations) {
          mutations.forEach(function (mutation) {
            if (
              mutation.type === "attributes" &&
              mutation.attributeName === "show_status"
            ) {
              const target = mutation.target;

              if (target.classList.contains("web_near_form")) {
                const showStatus = target.getAttribute("show_status");

                if (showStatus == "true") {
                  scrollPosition = window.scrollY;
                  document.body.style.overflow = "hidden";
                  document.body.style.position = "fixed";
                  document.body.style.top = `-${scrollPosition}px`;
                  document.body.style.width = "100%";
                } else {
                  const originalScrollBehavior = document.documentElement.style.scrollBehavior;
                  document.documentElement.style.scrollBehavior = "auto";
                  document.body.style.overflow = "";
                  document.body.style.position = "";
                  document.body.style.top = "";
                  window.scrollTo(0, scrollPosition);
                  document.documentElement.style.scrollBehavior = originalScrollBehavior;
                }
              }
            }
          });
        }

        // Create an observer instance
        const observer = new MutationObserver(handleMutation);

        // Configuration of the observer
        const config = { attributes: true, attributeFilter: ["show_status"] };

        document.querySelectorAll(".web_near_form").forEach(function (form) {
          observer.observe(form, config);
        });
      } else {
        console.log("MutationObserver not supported");
      }
    } catch (error) {
      console.error("initObservers", error);
    }
  }
  function getDeviceType() {
    var e = navigator.userAgent;
    return /mobile/i.test(e) ? "Mobile" : /iPad|Android|Touch/i.test(e) ? "Tablet" : "Desktop"
  }

  document.addEventListener("webNearLoaded", function(){
    
    if(getDeviceType() == "Mobile") {
      initObservers();
    }
    
  });


</script>