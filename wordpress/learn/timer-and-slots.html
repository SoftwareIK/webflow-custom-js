<script nitro-exclude>
  // webinar-type code start  ---------------------------------------------------------
  let webinarSlots = [];
  const webNearLoadedEv = new CustomEvent("webNearLoaded");
  // Get all URl Params
  function getAllUrlParams(url) {
    let queryString = url ? url.split('?')[1] : window.location.search.slice(1);
    let utmobj = {};
    if (queryString) {
      queryString = queryString.split('#')[0];
      let arr = queryString.split('&');
      for (let i = 0; i < arr.length; i++) {
        let a = arr[i].split('=');
        let paramName = a[0];
        let paramValue = typeof (a[1]) === 'undefined' ? true : a[1];
        paramName = paramName.toLowerCase();
        if (paramName.match(/\[(\d+)?\]$/)) {
          let key = paramName.replace(/\[(\d+)?\]/, '');
          if (!utmobj[key]) utmobj[key] = [];
          if (paramName.match(/\[\d+\]$/)) {
            let index = /\[(\d+)\]/.exec(paramName)[1];
            utmobj[key][index] = paramValue;
          } else {
            utmobj[key].push(paramValue);
          }
        } else {
          if (!utmobj[paramName]) {
            utmobj[paramName] = paramValue;
          } else if (utmobj[paramName] && typeof utmobj[paramName] === 'string') {
            utmobj[paramName] = [utmobj[paramName]];
            utmobj[paramName].push(paramValue);
          } else {
            utmobj[paramName].push(paramValue);
          }
        }
      }
    }
    return utmobj;
  }

  function getEventTitle(webinarType, event) {
    // If the event exists, decode it and return
    if (event) {
      return decodeURIComponent(event);
    }

    // Use the appropriate default title based on webinarType
    switch (webinarType) {
      case "CAREER_SESSION":
        return eventTitleMap["CAREER_SESSION"];
      case "SWITCH_UP":
        return eventTitleMap["SWITCH_UP"];
      case "ONE_TO_ONE_CONNECT":
        return eventTitleMap["ONE_TO_ONE_CONNECT"];
      default:
        return eventTitleMap["REGULAR"];
    }
  };

  const eventTitleMap = {
    CAREER_SESSION: "Seize the AI Advantage: Strengthen Your Resume",
    SWITCH_UP: "Uplevel your career with AI/ML/GenAI",
    ONE_TO_ONE_CONNECT: "How to Nail Your Next Tech/Product Interview",
    REGULAR: "How to Nail your next Technical Interview",
  };

  let currentURlPrms = getAllUrlParams();
  if (currentURlPrms.webinartype) {
    webinarType = currentURlPrms?.webinartype?.toLocaleUpperCase();
  }
  let isSwitchUp = "No";
  let v_timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  if (v_timezone === "Asia/Calcutta") v_timezone = "Asia/Kolkata";

  let is_webinar_1o1_eligible = webinarType === "ONE_TO_ONE_CONNECT";

  let eventName = getEventTitle(webinarType, currentURlPrms.event);
  // webinar-type code end ---------------------------------------------------------

  // Slot related code start  ---------------------------------------------------------
  let registration_type;
  let no_of_webinar_slots = 6;
  let slotFetchedTwice = false;
  let initnialWebinarType = webinarType;
  let initialTimezone = v_timezone;
  let api_status = "pending"; // "pending" | "on-going" | "completed" | "failed"
  let staticSlots = [];

  function generateWebinarSlots({ count, country, targetTimezone, webinarType }) {
    const getSlotConfigs = (region) => {
      switch (region) {
        case "IND":
          return {
            skipDay: 0, // Skip Sunday
            timeSlots: {
              0: null, // Skip Sunday
              1: "18:00:00", // Monday
              2: "18:00:00", // Tuesday
              3: "18:00:00", // Wednesday
              4: "18:00:00", // Thursday
              5: "18:00:00", // Friday
              6: "11:00:00", // Saturday
            },
            timeZone: "Asia/Kolkata",
            utcOffset: 5.5, // Offset in hours
          };
        default:
          return {
            skipDay: 6, // Skip Saturday
            timeSlots: {
              0: "20:30:00", // Sunday
              1: "19:30:00", // Monday
              2: "20:30:00", // Tuesday
              3: "19:30:00", // Wednesday
              4: "20:30:00", // Thursday
              5: "19:30:00", // Friday
              6: null, // Skip Saturday
            },
            timeZone: "America/New_York",
            utcOffset: -5, // Offset in hours
          };
      }
    };
    const formatDateWithTimezone = (date, offsetHours) => {
      // Get the year, month, day, hours, minutes, and seconds from the date
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      const seconds = String(date.getSeconds()).padStart(2, "0");

      // Calculate the absolute offset in hours and minutes
      const totalMinutesOffset = offsetHours * 60; // Convert fractional offset to total minutes
      const offsetHoursPart = Math.floor(Math.abs(totalMinutesOffset) / 60); // Integer hours
      const offsetMinutesPart = Math.abs(totalMinutesOffset) % 60; // Remainder as minutes

      // Construct the offset string in Â±HH:mm format
      const formattedOffset = `${offsetHours >= 0 ? "+" : "-"}${String(
        offsetHoursPart
      ).padStart(2, "0")}:${String(offsetMinutesPart).padStart(2, "0")}`;

      // Combine into the final ISO format
      return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${formattedOffset}`;
    };
    const convertToUTC = (dateString) => {
      // Parse the date using the timezone in the input string
      const localDate = new Date(dateString);

      // Convert to UTC components
      const utcYear = localDate.getUTCFullYear();
      const utcMonth = String(localDate.getUTCMonth() + 1).padStart(2, "0"); // Months are 0-indexed
      const utcDate = String(localDate.getUTCDate()).padStart(2, "0");
      const utcHours = String(localDate.getUTCHours()).padStart(2, "0");
      const utcMinutes = String(localDate.getUTCMinutes()).padStart(2, "0");
      const utcSeconds = String(localDate.getUTCSeconds()).padStart(2, "0");

      // Construct the UTC string in the desired format
      return `${utcYear}-${utcMonth}-${utcDate}T${utcHours}:${utcMinutes}:${utcSeconds}+00:00`;
    };
    const toTargetTimezone = (dateString, targetTimezone) => {
      // Parse the input date string
      const date = new Date(dateString);

      // Use Intl.DateTimeFormat to format the date in the target timezone
      const formatter = new Intl.DateTimeFormat("en-US", {
        timeZone: targetTimezone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hourCycle: "h23", // 24-hour format
      });

      // Format the date to the target timezone
      const parts = formatter.formatToParts(date);

      // Extract parts and construct ISO string
      const year = parts.find((p) => p.type === "year").value;
      const month = parts.find((p) => p.type === "month").value;
      const day = parts.find((p) => p.type === "day").value;
      const hour = parts.find((p) => p.type === "hour").value;
      const minute = parts.find((p) => p.type === "minute").value;
      const second = parts.find((p) => p.type === "second").value;

      return `${year}-${month}-${day}T${hour.padStart(2, "0")}:${minute.padStart(
        2,
        "0"
      )}:${second.padStart(2, "0")}`;
    };
    const formatTime = (date) => {
      return date
        .toLocaleString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        })
        ?.replaceAll(" ", "");
    };
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, "0"); // Pad day with leading zero
      const month = date.toLocaleString("en-US", { month: "long" });
      const year = date.getFullYear();
      const weekday = date.toLocaleString("en-US", { weekday: "long" });

      return `${weekday}, ${month} ${day}, ${year}`;
    };
    const addOffset = (dateString, timezone) => {
      try {
        const date = new Date();
        const options = { timeZone: timezone, timeZoneName: "longOffset" };

        let offset =
          Intl.DateTimeFormat("en-US", options)
            .formatToParts(date)
            .find((part) => part.type === "timeZoneName")
            ?.value?.replace("GMT", "") || "+00:00";

        // Add padding to hours if needed
        if (offset.match(/^[+-]\d:/)) {
          offset = offset.replace(/^([+-])(\d):/, "$10$2:");
        }

        return `${dateString}${offset}`;
      } catch {
        return `${dateString}"+00:00"`;
      }
    };

    const slotConfig = getSlotConfigs(country);

    if (!slotConfig) {
      throw new Error("Invalid country.");
    }

    const {
      skipDay,
      timeSlots,
      utcOffset: slotUTCOffset,
      timeZone: slotTimezone,
    } = slotConfig;

    const result = [];
    const now = new Date(
      new Date().toLocaleString("en-US", { timeZone: slotTimezone })
    );

    for (let i = 0; i < count; i++) {
      const startSlotTime = new Date(now);
      startSlotTime.setDate(startSlotTime.getDate() + i);

      const day = startSlotTime.getDay();
      if (day === skipDay) {
        continue;
      }

      const slotTime = timeSlots[day];
      if (!slotTime) {
        continue;
      }

      const [hours, minutes, seconds] = slotTime.split(":").map(Number);
      startSlotTime.setHours(hours);
      startSlotTime.setMinutes(minutes);
      startSlotTime.setSeconds(seconds);

      // Skip past slots
      if (startSlotTime < new Date(now)) {
        continue;
      }

      const endSlotTime = new Date(startSlotTime);
      endSlotTime.setHours(endSlotTime.getHours() + 1);

      const formatted_start_slot_time = formatDateWithTimezone(
        startSlotTime,
        slotUTCOffset
      );
      const formatted_end_slot_time = formatDateWithTimezone(
        endSlotTime,
        slotUTCOffset
      );

      const user_start_time_obj = new Date(
        toTargetTimezone(formatted_start_slot_time, targetTimezone)
      );
      const user_end_time_obj = new Date(
        toTargetTimezone(formatted_end_slot_time, targetTimezone)
      );

      result.push({
        start_time: addOffset(
          toTargetTimezone(formatted_start_slot_time, targetTimezone),
          targetTimezone
        ),
        end_time: addOffset(
          toTargetTimezone(formatted_end_slot_time, targetTimezone),
          targetTimezone
        ),
        utc_start_time: convertToUTC(formatted_start_slot_time),
        utc_end_time: convertToUTC(formatted_end_slot_time),
        day: String(user_start_time_obj.getDate()).padStart(2, "0"),
        month: String(user_start_time_obj.getMonth() + 1).padStart(2, "0"),
        year: String(user_start_time_obj.getFullYear()),
        hour: String(user_start_time_obj.getHours() % 12 || 12).padStart(2, "0"),
        minute: String(user_start_time_obj.getMinutes()).padStart(2, "0"),
        second: String(user_start_time_obj.getSeconds()).padStart(2, "0"),
        am_or_pm: user_start_time_obj.getHours() >= 12 ? "PM" : "AM",
        weekday: user_start_time_obj.toLocaleString("en-US", { weekday: "long" }),
        invitee_start_time: `${formatTime(user_start_time_obj)} - ${formatDate(
          user_start_time_obj
        )}`,
        invitee_end_time: `${formatTime(user_end_time_obj)} - ${formatDate(
          user_end_time_obj
        )}`,
        webinar_lead_type: webinarType,
      });
    }
    return result;
  }

  function observeWebinarType() {
    let previousValue = "";
    let previousTimezone = v_timezone;
    function checkForChange() {
      if (webinarType !== previousValue || v_timezone !== previousTimezone) {
        previousValue = webinarType;
        if (webinarType) {
          try {
            let t_zone = v_timezone || Intl.DateTimeFormat().resolvedOptions().timeZone
            if (t_zone == 'Asia/Calcutta') {
              t_zone = 'Asia/Kolkata';
            }
            staticSlots = generateWebinarSlots({ count: 13, country: "USA", targetTimezone: v_timezone, webinarType: webinarType });
            if (["pending", "failed"].includes(api_status)) {
              slotLoaded(staticSlots);
            }
          } catch (error) {
            console.error("P1: Error while generating static slots", error);
          }
        }
      }
    }

    const interval = setInterval(checkForChange, 100);

    setTimeout(() => {
      clearInterval(interval);
    }, 5000);
  }
  observeWebinarType();

  function populateWebinarSlots(resobj) {
    const t_months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    if (resobj.length == 0) {
      console.error("P0: The Uplevel Webinar Slots API Returned No Data.");
      registration_type = "calendly";
    } else {
      registration_type = "byecalendly";
    }

    no_of_webinar_slots = (no_of_webinar_slots == undefined) ? 4 : no_of_webinar_slots;
    let nslots = (resobj.length > no_of_webinar_slots) ? no_of_webinar_slots : resobj.length;
    var tz = new Date().toString().match(/\((.+)\)/);
    if (tz[1].includes(" ")) {
      tz = tz[1]
        .split(" ")
        .map(([first]) => first)
        .join("");
    }

    const getWebinerSlots = document?.querySelector('.webnear_regitration_fr .fr_stage_2 .web_near_slot');
    getWebinerSlots.innerHTML = "";

    for (i = 0; i < nslots; i++) {
      let hdate = resobj[i].weekday + ", " + resobj[i].day + " " + t_months[parseInt(resobj[i].month) - 1] + " " + resobj[i].year + " | " + resobj[i].hour + ":" + resobj[i].minute + " " + resobj[i].am_or_pm;

      let checkStatus = i == 0 ? "checked" : "";
      let radiohtml = document.createElement('label');
      radiohtml.innerHTML = `
              <input type="radio" 
              name="start-date"
              value="${resobj[i].start_time}" 
              data-endtime="${resobj[i].end_time}" 
              data-invitee_starttime="${resobj[i].invitee_start_time}" 
              data-invitee_endtime="${resobj[i].invitee_end_time}" 
              data-name="${resobj[i].start_time}" 
              data-webinar_lead_type="${resobj[i].webinar_lead_type}"
              ${checkStatus} 
              required="required">
              <span class="text">${hdate} </span>
          `;

      getWebinerSlots.append(radiohtml);
    }
  }

  async function fallbackSlots() {
    if (!slotFetchedTwice) {
      let initnialWebinarType = webinarType;
      let initialTimezone = v_timezone;
      webinarType = "REGULAR";
      v_timezone = "America/New_York"
      loadSlot(v_timezone)
      slotFetchedTwice = true;
    } else {
      webinarType = initnialWebinarType;
      v_timezone = initialTimezone;
      if (staticSlots.length == 0) {
        staticSlots = generateWebinarSlots({ count: 13, country: "USA", targetTimezone: v_timezone, webinarType: webinarType });
      }
      slotLoaded(staticSlots);
    }
  }

  async function slotLoaded(slots) {
    webinarSlots = slots
    document.dispatchEvent(webNearLoadedEv);
    if (!is_webinar_1o1_eligible) {
      populateWebinarSlots(slots);
    }
    TimerHandler(slots);
  }

  async function loadSlot(c_timezoon = "America/New_York") {
    let api_url = `https://uplevel.interviewkickstart.com/api/webinar-slot/upcoming-slots/?country=USA&program=Backend&timezone=${c_timezoon.replace("+", "%2B")}&type=${webinarType === "SWITCH_UP" ? webinarType : "REGULAR"}`;

    const option = {
      method: "GET",
      headers: {
        "Authorization": "1Cgx6oYXkOlWkNDn7_tXO",
      }
    }
    try {
      api_status = "on-going";
      const request = await fetch(api_url, option);
      let resobj = await request.json();
      resobj = resobj.map(item => ({ ...item, webinar_lead_type: webinarType }));
      if (resobj.length == 0) {
        throw new Error(`P0: The Uplevel Webinar Slots API Returned No Data. (webinarType: ${webinarType}, timezone: ${c_timezoon})`);
      }
      slotLoaded(resobj);
      api_status = "completed";
      if (!is_webinar_1o1_eligible) {
        populateWebinarSlots(resobj);
      }
    } catch (err) {
      api_status = "failed";
      fallbackSlots()
    }
  }

  getGeo().then((geo) => {
    loadSlot(geo.timezone);
  }).catch(() => {
    loadSlot();
  })

  async function getGeo() {
    let response = await fetch("https://get.geojs.io/v1/ip/geo.json");
    let data = await response.json();
    return data;
  }

  // Slot related code end ---------------------------------------------------------

  // Timer related code start   ---------------------------------------------------------
  const timerState = {
    currentDate: '',
    nextDate: '',
    currentDateSec: '',
    nextDateSec: '',
  };

  function initStates(slots, tz) {
    try {
      timerState.currentDate = new Date().toLocaleString('en-US', { timeZone: tz });
    } catch (err) {
      console.error(err);
    }

    timerState.currentDateSec = Date.parse(timerState.currentDate);
    timerState.nextDate = nextWebinar(timerState.currentDate.split(',')[0], timerState.currentDateSec, slots, tz);
    if (timerState.nextDate !== '') {
      timerState.nextDateSec = Date.parse(timerState.nextDate);
    }
  };

  function nextWebinar(currentDate, currentWebTime, slots, tz) {
    let nextWebinarDate = '';
    if (!slots) {
      return fallbackTimerDate(tz)
    }

    const formattedSlots = (slots || [])?.map((slot = {}) => ({
      date: `${slot.month}/${slot.day}/${slot.year}`, //"06/12/2024"
      time: `${slot.hour}:${slot.minute}:${slot.second} ${slot.am_or_pm}`, //"07:30:00 PM"
    }))

    for (let idx = 0; idx < formattedSlots.length; idx++) {
      if (formattedSlots[idx]) {
        const currentDateWeb = Date.parse(new Date(`${formattedSlots[idx].date}, ${formattedSlots[idx].time}`));
        if (currentDateWeb > currentWebTime) {
          nextWebinarDate = `${formattedSlots[idx].date}, ${formattedSlots[idx].time}`;
          break;
        }
      }
    }
    return nextWebinarDate;
  };

  // Fall back time
  function fallbackTimerDate(tz) {
    const isIndia = tz == "IST" || tz == "Asia/Kolkata";

    const currentDate = new Date();
    const dayOfWeek = currentDate.getDay(); // 0: Sunday, 1: Monday, ..., 6: Saturday
    const dateString = currentDate.toLocaleDateString('en-US', { timeZone: 'Asia/Kolkata', month: '2-digit', day: '2-digit', year: 'numeric' });
    let timeString;

    if (isIndia) {
      if (dayOfWeek === 6) {
        // Saturday
        timeString = "11:00:00 PM";
      } else if (dayOfWeek === 0) {
        // Sunday
        return ""; // Skip on Sunday
      } else {
        timeString = "06:00:00 PM";
      }
    } else {
      if (dayOfWeek === 6) {
        // Saturday
        return ""; // Skip on Saturday
      } else if (dayOfWeek % 2 === 1) {
        // Odd days (Monday, Wednesday, Friday, Sunday)
        timeString = "07:30:00 PM";
      } else {
        // Even days (Tuesday, Thursday)
        timeString = "08:30:00 PM";
      }
    }

    return `${dateString}, ${timeString}`
  }

  function unitCount(unit) {
    const toTens = () => String(Number.parseInt(unit / 10));
    const toOnes = () => String(unit % 10);
    return toTens() + toOnes();
  };

  let webinarTimer;

  function TimerHandler(slots) {

    let tz = "America/New_York"
    if (typeof (v_timezone) != "undefined") {
      tz = v_timezone;
    }
    clearInterval(webinarTimer);
    // initialize states
    initStates(slots, tz);

    // start timer
    webinarTimer = setInterval(() => {
      if (timerState.nextDate === '') {
        clearInterval(webinarTimer);
      }
      timerState.currentDate = new Date().toLocaleString('en-US', { timeZone: tz });
      timerState.currentDateSec = Date.parse(timerState.currentDate);

      const distanceCount = timerState.nextDateSec - timerState.currentDateSec;

      const day = Math.floor(distanceCount / (1000 * 60 * 60 * 24));
      const hrs = Math.floor((distanceCount % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const min = Math.floor((distanceCount % (1000 * 60 * 60)) / (1000 * 60));
      const sec = Math.floor((distanceCount % (1000 * 60)) / 1000);

      // separating into tens and ones

      const dayCount = unitCount(day);
      const hrCount = unitCount(hrs);
      const minCount = unitCount(min);
      const secCount = unitCount(sec);

      // update UI
      updateTimerUI(dayCount, hrCount, minCount, secCount);

      if (distanceCount <= 0) {
        // move timer to next date if reached 0
        initStates(slots, tz);

        if (timerState.nextDate === '') {
          clearInterval(webinarTimer);
          // hide the fild if nothing
          document.querySelectorAll('.webinar__timer').forEach((timer) => {
            timer.classList.add('is-hidden');
          });
        }
      }
    }, 1000);
  };

  // set the next webnear value
  function updateTimerUI(day, hrs, min, sec) {
    document.querySelectorAll('.webinar__timer--days h2').forEach((timer) => {
      timer.textContent = day;
    });
    document.querySelectorAll('.webinar__timer--hours h2').forEach((timer) => {
      timer.textContent = hrs;
    });
    document.querySelectorAll('.webinar__timer--mins h2').forEach((timer) => {
      timer.textContent = min;
    });
    document.querySelectorAll('.webinar__timer--secs h2').forEach((timer) => {
      timer.textContent = sec.slice(0, 2);
    });
  };
  // Timer related code end ---------------------------------------------------------
</script>